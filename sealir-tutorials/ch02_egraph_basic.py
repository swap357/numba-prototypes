# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.16.7
#   kernelspec:
#     display_name: sealir_basic_compiler
#     language: python
#     name: python3
# ---

# ## Ch 2. Adding the EGraph middle-end
#
# Traditional compiler design depends on a series of compiler passes. However,
# this approach suffers from the phase-ordering problem—where the specific order
# of optimization steps can influence the resulting code, often leading to
# missed optimizations or less efficient output due to the inflexible sequence
# of transformations. The use of EGraphs and Equality Saturation overcomes this
# issue. By representing a program as a graph of equivalent expressions and
# evaluating multiple optimization possibilities at once, these techniques
# enable the compiler to identify the most effective code version without being
# limited by a predetermined order of passes.
#
# In this chapter, we will define the middle end—--the stage of a compiler that
# optimizes and transforms an intermediate representation (IR) of a program,
# connecting the front end (which converts source code into IR) to the back end
# (which produces target machine code). The egglog library powers our use of
# EGraphs. Before exploring how to write rules for EGraphs, we’ll first
# establish a conversion from RVSDG-IR to EGraph. RVSDG-IR must be encoded into
# the EGraph, enabling us to apply rewrite rulesets for program optimization or
# analysis. Afterward, an extraction step selects the most efficient variant
# from the EGraph.

from egglog import EGraph
from sealir import rvsdg
from sealir.eqsat.rvsdg_convert import egraph_conversion
from sealir.eqsat.rvsdg_eqsat import GraphRoot
from sealir.eqsat.rvsdg_extract import egraph_extraction

# We'll be extending from chapter 1.
from ch01_basic_compiler import backend, frontend, jit_compile, run_test
from utils import IN_NOTEBOOK

# ## A simple roundtripping to and from EGraph
#
# Our initial middle-end is a simple roundtripping from RVSDG-IR to EGraph and
# back to RVSDG-IR. `SealIR` provides `egraph_conversion()` for RVSDG-IR to
# EGraph, and `egraph_extraction()` for EGraph to RVSDG-IR.
#
# ### Convert to EGraph
#
# The following code shows the RVSDG-IR and egraph for the `max_if_else()`
# function. The two are almost a direct mapping.

if __name__ == "__main__":

    def max_if_else(x, y):
        if x > y:
            return x
        else:
            return y

    # Get RVSDG
    rvsdg_expr, dbginfo = frontend(max_if_else)
    print(rvsdg.format_rvsdg(rvsdg_expr))
    # Convert RVSDG to Egraph
    memo = egraph_conversion(rvsdg_expr)
    func = memo[rvsdg_expr]

    egraph = EGraph()
    egraph.let("root", GraphRoot(func))
    if IN_NOTEBOOK:
        egraph.display(graphviz=True)

# ### Extract from EGraph
#
# An EGraph can represent numerous variants of a program.
# These variants are generated by applying rewrite rules,
# which produce equivalent versions of the code that differ in structure or
# efficiency. While all variants are functionally identical,
# we are primarily interested in identifying the "best" one,
# where "best" depends on context--—such as execution speed, code size, or
# energy efficiency. To address this, the `egraph_extraction()` function allows
# users to define custom cost models, tailoring the selection process to
# prioritize the variant that aligns with their specific optimization goals.
#

if __name__ == "__main__":
    help(egraph_extraction)

# Here, we will use the default cost model, which is based on the node count.

if __name__ == "__main__":
    cost, extracted = egraph_extraction(egraph, rvsdg_expr)
    print(rvsdg.format_rvsdg(extracted))


# ## Putting the middle-end logic together


def middle_end(rvsdg_expr, apply_to_egraph):
    """The middle end encode the RVSDG into a EGraph to apply rewrite rules.
    After that, it is extracted back into RVSDG.
    """
    # Convert to egraph
    memo = egraph_conversion(rvsdg_expr)

    func = memo[rvsdg_expr]

    egraph = EGraph()
    apply_to_egraph(egraph, func)

    # Extraction
    cost, extracted = egraph_extraction(egraph, rvsdg_expr)
    return cost, extracted


# Here, we redefine the compiler pipeline to include the middle-end.


def compiler_pipeline(fn, *, verbose=False):
    rvsdg_expr, dbginfo = frontend(fn)

    # Middle end
    def define_egraph(egraph: EGraph, func):
        # For now, the middle end is just an identity function that exercise
        # the encoding into and out of egraph.
        root = GraphRoot(func)
        egraph.let("root", root)
        if verbose and IN_NOTEBOOK:
            # For inspecting the egraph
            egraph.display(graphviz=True)

    cost, extracted = middle_end(rvsdg_expr, define_egraph)
    print("Extracted from EGraph".center(80, "="))
    print("cost =", cost)
    print(rvsdg.format_rvsdg(extracted))

    llmod = backend(extracted)
    return jit_compile(llmod, extracted)


# The following exercises our new pipeline:

if __name__ == "__main__":

    def sum_ints(n):
        c = 1 + n
        for i in range(n):
            c += i
        return c

    jt = compiler_pipeline(sum_ints, verbose=True)
    run_test(sum_ints, jt, (12,))
