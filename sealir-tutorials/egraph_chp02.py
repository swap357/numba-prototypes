# %% [markdown]
# ## Ch 2. Adding the EGraph middle-end
# 
# Traditional compiler design depends on a series of compiler passes. However,
# this approach suffers from the phase-ordering problem—where the specific order
# of optimization steps can influence the resulting code, often leading to
# missed optimizations or less efficient output due to the inflexible sequence
# of transformations. The use of EGraphs and Equality Saturation overcomes this
# issue. By representing a program as a graph of equivalent expressions and
# evaluating multiple optimization possibilities at once, these techniques
# enable the compiler to identify the most effective code version without being
# limited by a predetermined order of passes.
# 
# In this chapter, we will define the middle end—--the stage of a compiler that
# optimizes and transforms an intermediate representation (IR) of a program,
# connecting the front end (which converts source code into IR) to the back end
# (which produces target machine code). The egglog library powers our use of
# EGraphs. Before exploring how to write rules for EGraphs, we’ll first
# establish a conversion from RVSDG-IR to EGraph. RVSDG-IR must be encoded into
# the EGraph, enabling us to apply rewrite rulesets for program optimization or
# analysis. Afterward, an extraction step selects the most efficient variant
# from the EGraph.

# %%
from egglog import EGraph
from sealir import rvsdg
from sealir.eqsat.rvsdg_convert import egraph_conversion
from sealir.eqsat.rvsdg_eqsat import GraphRoot
from sealir.eqsat.rvsdg_extract import egraph_extraction

# %%
# We'll be extending from chapter 1.
from ch01_basic_compiler import backend, frontend, jit_compile, run_test
from utils import IN_NOTEBOOK

# %% [markdown]
# ## A simple roundtripping to and from EGraph
# 
# Our initial middle-end is a simple roundtripping from RVSDG-IR to EGraph and
# back to RVSDG-IR. `SealIR` provides `egraph_conversion()` for RVSDG-IR to
# EGraph, and `egraph_extraction()` for EGraph to RVSDG-IR.
# 
# ### Convert to EGraph
# 
# The following code shows the RVSDG-IR and egraph for the `max_if_else()`
# function. The two are almost a direct mapping.

# %%
if __name__ == "__main__":

    def max_if_else(x, y):
        if x > y:
            return x
        else:
            return y

    # Get RVSDG
    rvsdg_expr, dbginfo = frontend(max_if_else)
    print(rvsdg.format_rvsdg(rvsdg_expr))
    
    # Convert RVSDG to Egraph
    memo = egraph_conversion(rvsdg_expr)
    print("memo")
    print(memo)
    print(type(memo))
    print()
    print("rvsdg_expr")
    func = memo[rvsdg_expr]
    print(func)
    print(type(func))
    egraph = EGraph()
    egraph.let("root", GraphRoot(func))
    
    if IN_NOTEBOOK:
        egraph.display(graphviz=True)

# %%
dot = rvsdg_expr._tape.render_dot(only_reachable=True)
dot.render("my_function", format="svg")

# %% [markdown]
# ### Extract from EGraph
# 
# An EGraph can represent numerous variants of a program.
# These variants are generated by applying rewrite rules,
# which produce equivalent versions of the code that differ in structure or
# efficiency. While all variants are functionally identical,
# we are primarily interested in identifying the "best" one,
# where "best" depends on context--—such as execution speed, code size, or
# energy efficiency. To address this, the `egraph_extraction()` function allows
# users to define custom cost models, tailoring the selection process to
# prioritize the variant that aligns with their specific optimization goals.
# 

# %%
if __name__ == "__main__":
    help(egraph_extraction)

# %% [markdown]
# Here, we will use the default cost model, which is based on the node count.

# %%
if __name__ == "__main__":
    cost, extracted = egraph_extraction(egraph, rvsdg_expr)
    print(rvsdg.format_rvsdg(extracted))

# %%


# %%
from rvsdg_diagram_util import create_rvsdg_diagram
from mermaid import Mermaid

before_mermaid_diagram = create_rvsdg_diagram(rvsdg_expr, "EGraph-before")
after_mermaid_diagram = create_rvsdg_diagram(extracted, "EGraph-after")

Mermaid(before_mermaid_diagram)


# %%
from mermaid import Mermaid
Mermaid(mermaid_diagram)

# %%
from mermaid import Mermaid
Mermaid(after_mermaid_diagram)

# %% [markdown]
# ## Putting the middle-end logic together

# %%
def middle_end(rvsdg_expr, apply_to_egraph):
    """The middle end encode the RVSDG into a EGraph to apply rewrite rules.
    After that, it is extracted back into RVSDG.
    """
    # Convert to egraph
    memo = egraph_conversion(rvsdg_expr)

    func = memo[rvsdg_expr]

    egraph = EGraph()
    apply_to_egraph(egraph, func)

    # Extraction
    cost, extracted = egraph_extraction(egraph, rvsdg_expr)
    return cost, extracted

# %% [markdown]
# Here, we redefine the compiler pipeline to include the middle-end.

# %%
def compiler_pipeline(fn, *, verbose=False):
    rvsdg_expr, dbginfo = frontend(fn)

    # Middle end
    def define_egraph(egraph: EGraph, func):
        # For now, the middle end is just an identity function that exercise
        # the encoding into and out of egraph.
        root = GraphRoot(func)
        egraph.let("root", root)
        # if verbose and IN_NOTEBOOK:
        #     # For inspecting the egraph
        #     egraph.display(graphviz=True)

    cost, extracted = middle_end(rvsdg_expr, define_egraph)
    before_mermaid_diagram = create_rvsdg_diagram(rvsdg_expr, "Before EGraph")
    after_mermaid_diagram = create_rvsdg_diagram(extracted, "After EGraph")
    # print("Extracted from EGraph".center(80, "="))
    # print("cost =", cost)
    # print(rvsdg.format_rvsdg(extracted))

    llmod = backend(extracted)
    return jit_compile(llmod, extracted), before_mermaid_diagram, after_mermaid_diagram

# %% [markdown]
# The following exercises our new pipeline:

# %%
if __name__ == "__main__":

    def sum_ints(n):
        c = 1 + n
        for i in range(n):
            c += i
        return c

    jt, before_mermaid_diagram, after_mermaid_diagram = compiler_pipeline(sum_ints, verbose=True)
    print(f"{before_mermaid_diagram}")
    print(f"{after_mermaid_diagram}")
    
    
    # run_test(sum_ints, jt, (12,))

# %%
from mermaid import Mermaid
Mermaid(before_mermaid_diagram)

# %%
Mermaid(after_mermaid_diagram)


